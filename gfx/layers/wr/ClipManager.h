/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#ifndef GFX_CLIPMANAGER_H
#define GFX_CLIPMANAGER_H

#include <unordered_map>

#include "mozilla/Attributes.h"
#include "mozilla/webrender/WebRenderAPI.h"

class nsDisplayItem;

namespace mozilla {

struct ActiveScrolledRoot;
struct DisplayItemClipChain;

namespace wr {
class DisplayListBuilder;
}

namespace layers {

class StackingContextHelper;
class WebRenderLayerManager;

class ClipManager
{
public:
  ClipManager();

  void BeginBuild(WebRenderLayerManager* aManager,
                  wr::DisplayListBuilder& aBuilder);
  void EndBuild();

  void BeginList(const StackingContextHelper& aStackingContext);
  void EndList(const StackingContextHelper& aStackingContext);

  void BeginItem(nsDisplayItem* aItem,
                 const StackingContextHelper& aStackingContext);
  ~ClipManager();

  void PushOverrideForASR(const ActiveScrolledRoot* aASR,
                          const Maybe<wr::WrClipId>& aClipId);
  void PopOverrideForASR(const ActiveScrolledRoot* aASR);

private:
  Maybe<wr::WrClipId> ClipIdAfterOverride(const Maybe<wr::WrClipId>& aClipId);

  Maybe<wr::WrClipId>
  DefineScrollLayers(const ActiveScrolledRoot* aASR,
                     nsDisplayItem* aItem,
                     const StackingContextHelper& aSc);

  Maybe<wr::WrClipChainId>
  DefineClipChain(const DisplayItemClipChain* aChain,
                  int32_t aAppUnitsPerDevPixel,
                  const StackingContextHelper& aSc);

  typedef std::unordered_map<const DisplayItemClipChain*, wr::WrClipId> ClipIdMap;

  WebRenderLayerManager* MOZ_NON_OWNING_REF mManager;
  wr::DisplayListBuilder* mBuilder;
  // Stack of clip caches. There is one entry in the stack for each reference
  // frame that is currently pushed in WR (a reference frame is a stacking
  // context with a non-identity transform). Each entry contains a map that
  // maps gecko DisplayItemClipChain objects to webrender WrClipIds, which
  // allows us to avoid redefining identical clips in WR. We need to keep a
  // separate cache per reference frame because the DisplayItemClipChain items
  // themselves get deduplicated without regard to reference frames, but on the
  // WR side we need to create different clips if they are in different
  // reference frames.
  std::vector<ClipIdMap> mCacheStack;

  // A map that holds the cache overrides creates by "out of band" clips, i.e.
  // clips that are generated by display items but that ClipManager
  // doesn't know about. These are called "cache overrides" because while we're
  // inside one of these clips, the WR clip stack is different from what
  // ClipManager thinks it actually is (because of the out-of-band
  // clip that was pushed onto the stack) and so ClipManager cannot
  // use its clip cache as-is. Instead, any time ClipManager wants
  // to define a new clip as a child of clip X, it should first check the
  // cache overrides to see if there is an out-of-band clip Y that is already a
  // child of X, and then define its clip as a child of Y instead. This map
  // stores X -> ClipId of Y, which allows ClipManager to do the
  // necessary lookup. Note that there theoretically might be multiple
  // different "Y" clips which is why we need a vector.
  std::unordered_map<uint64_t, std::vector<Maybe<wr::WrClipId>>> mASROverride;

  struct ItemClips {
    ItemClips(const ActiveScrolledRoot* aASR,
              const DisplayItemClipChain* aChain);

    const ActiveScrolledRoot* mASR;
    const DisplayItemClipChain* mChain;

    Maybe<wr::WrClipId> mScrollId;
    Maybe<wr::WrClipChainId> mClipChainId;
    bool mApplied;

    void Apply(wr::DisplayListBuilder* aBuilder);
    void Unapply(wr::DisplayListBuilder* aBuilder);
    bool HasSameInputs(const ItemClips& aOther);
    void CopyOutputsFrom(const ItemClips& aOther);
  };

  std::vector<ItemClips> mItemClipStack;
};

} // namespace layers
} // namespace mozilla

#endif
